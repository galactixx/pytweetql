from typing import Any, Dict, Generator, List
import copy

from pytweetql.errors import *
from pytweetql._typing import APIResponse
from pytweetql._utils._utils import (
    empty_dictionary,
    extract_dicts_from_list
)
from pytweetql.validation._node_path import (
    NodePath,
    PathNode
)
from pytweetql.validation._base_validation import (
    BaseValidation,
    status_code_check
)

class DirectPathValidation(BaseValidation):
    """
    Functionality to parse and validate a direct path to dictionaries in a JSON.

    Args:
        response (APIResponse): The response generated by API.
        schema (dict): A list of PathNode classes to be constructed into
            doubly linked list.
    """
    def __init__(self, response: APIResponse, schema: Dict[str, dict]):
        super().__init__(response=response)
        if 'entry' not in schema or 'objects' not in schema:
            raise TypeError("Schema must only have 'entry' and 'objects' keys")

        self._schema = schema
        self._node_path_main = NodePath(schema=schema['entry'])

        self._validate_response()
        if empty_dictionary(source=self.response):
            self._error(error=ERROR_EMPTY)

    def _if_been_list(self, response: List[dict], current_node: PathNode) -> List[dict]:
        """"""
        key_search = []
        for item in response:
            if isinstance(item, dict):
                list_value = item.get(current_node.key)
                if list_value is not None:
                    key_search.append(list_value)
        return key_search

    @status_code_check
    def validate_and_parse(self) -> Generator[Any, None, None]:
        """"""
        entries = self._validate_main_schema(
            node_path=self._node_path_main,
            responses=self.response
        )
        for entry in entries:
            entry_results = {}
            for arg, schema in self._schema['objects'].items():
                results = self._validate_main_schema(
                    node_path=NodePath(schema=schema), 
                    responses=[entry]
                )
                for result in results:
                    entry_results.update({arg: result})
            yield entry_results

    @status_code_check
    def _validate_main_schema(
        self,
        node_path: NodePath,
        responses: List[dict]
    ) -> Generator[Any, None, None]:
        """
        Validate schema of response by navigating through linked list key path.
        
        Args:
            responses (List[dict]): A list of response dictionaries.

        Returns:
            Generator[Any, None, None]: Generator that yields any data type.
        """
        for resp in responses:
            current_node = node_path.head
            while current_node is not None:

                # Find the current node key in response
                key_search = None
                if node_path.been_list:
                    key_search = self._if_been_list(
                        response=resp, 
                        current_node=current_node
                    )
                elif isinstance(resp, dict):
                    key_search = resp.get(current_node.key)

                # Match type of found value to expected type
                if node_path.isinstance_of_type(
                    key_search=key_search, 
                    node=current_node
                ):
                    resp = copy.copy(key_search)
                    previouse_node = current_node.prev

                    # If value of previous node was a list,
                    # then extract all objects from the result
                    if (
                        previouse_node is not None and 
                        previouse_node.value_type == 'list'
                    ):
                        resp = extract_dicts_from_list(source=resp) 

                    # If current node is a result, then add to entries and break
                    if not current_node.next:
                        if isinstance(resp, list):
                            for record in resp:
                                yield record
                        else:
                            yield resp
                        break
                    else:
                        current_node = current_node.next
                else:
                    self._error(error=ERROR_PARSER)
                    break