from typing import Any, Generator, List, Tuple
import copy

from pytweetql.errors import *
from pytweetql.validation._base_validation import BaseValidation
from pytweetql.validation._nodes import nodes_error_api
from pytweetql._typing import (
    APIResponse, 
    Schema
)
from pytweetql._utils._utils import (
    empty_dictionary,
    extract_dicts_from_list
)
from pytweetql.validation._node_path import (
    NodePath,
    PathNode
)

def _derive_node_path(schema: Schema) -> NodePath:
    """"""
    return NodePath(schema=schema)


def _schema_validate(schema: Schema) -> None:
    """Validate that node schema has been properly specified."""
    if 'entry' not in schema or 'objects' not in schema:
        raise TypeError("Schema must only have 'entry' and 'objects' keys")
    

def _load_schema(schema: Schema) -> Tuple[dict, dict]:
    """Validate and load schema specification."""
    _schema_validate(schema=schema)
    return schema['entry'], schema['objects']


class DirectPathValidation(BaseValidation):
    """
    Functionality to parse and validate a direct path to dictionaries in a JSON.

    Args:
        response (APIResponse): The response generated by API.
    """
    def __init__(self, response: APIResponse, do_errors: bool = False):
        super().__init__(response=response)

        if not do_errors:
            # Detect and extract any API errors in response
            self._extract_api_errors()

            # Validate response and check if result is empty
            self._validate_response()
        if empty_dictionary(source=self.response):
            self._error(error=ERROR_EMPTY)
        
    def _extract_api_errors(self) -> None:
        """
        """
        errors = self.extract_objects(schema=nodes_error_api)
        for error in errors:
            self._error(
                error=generate_api_error(**error)
            )

    def _if_been_list(
        self, 
        response: List[dict], 
        current_node: PathNode
    ) -> List[dict]:
        """"""
        key_search = []
        for item in response:
            if isinstance(item, dict):
                list_value = item.get(current_node.key)
                if list_value is not None:
                    key_search.append(list_value)
        return key_search

    def extract_objects(self, schema: Schema) -> Generator[Any, None, None]:
        """"""
        # Load in schema
        schema_entry, schema_objects = _load_schema(schema=schema)

        # Derive entry node path
        node_path_entry = _derive_node_path(schema=schema_entry)

        # Validate schema
        entries = self._validate_schema(
            node_path=node_path_entry,
            responses=self.response
        )
        for entry in entries:
            entry_results = {}
            for arg, schema in schema_objects.items():
                results = self._validate_schema(
                    node_path=_derive_node_path(schema=schema),
                    responses=[entry]
                )
                for result in results:
                    entry_results.update({arg: result})
            yield entry_results

    def _validate_schema(
        self,
        node_path: NodePath,
        responses: List[dict]
    ) -> Generator[Any, None, None]:
        """
        Validate schema of response by navigating through linked list key path.
        
        Args:
            responses (List[dict]): A list of response dictionaries.

        Returns:
            Generator[Any, None, None]: Generator that yields any data type.
        """
        for resp in responses:
            current_node = node_path.head
            while current_node is not None:

                # Find the current node key in response
                key_search = None
                if node_path.been_list:
                    key_search = self._if_been_list(
                        response=resp, 
                        current_node=current_node
                    )
                elif isinstance(resp, dict):
                    key_search = resp.get(current_node.key)

                # Match type of found value to expected type
                if node_path.isinstance_of_type(
                    key_search=key_search, 
                    node=current_node
                ):
                    resp = copy.copy(key_search)
                    previouse_node = current_node.prev

                    # If value of previous node was a list,
                    # then extract all objects from the result
                    if (
                        previouse_node is not None and 
                        previouse_node.value_type == 'list'
                    ):
                        resp = extract_dicts_from_list(source=resp) 

                    # If current node is a result, then add to entries and break
                    if not current_node.next:
                        if isinstance(resp, list):
                            for record in resp:
                                yield record
                        else:
                            yield resp
                        break
                    else:
                        current_node = current_node.next
                else:
                    break